{"ast":null,"code":"var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\\1?|[aA]|\"[^\"]*\"|'[^']*'/g;\nvar twoDigitsOptional = \"[1-9]\\\\d?\";\nvar twoDigits = \"\\\\d\\\\d\";\nvar threeDigits = \"\\\\d{3}\";\nvar fourDigits = \"\\\\d{4}\";\nvar word = \"[^\\\\s]+\";\nvar literal = /\\[([^]*?)\\]/gm;\n\nfunction shorten(arr, sLen) {\n  var newArr = [];\n\n  for (var i = 0, len = arr.length; i < len; i++) {\n    newArr.push(arr[i].substr(0, sLen));\n  }\n\n  return newArr;\n}\n\nvar monthUpdate = function (arrName) {\n  return function (v, i18n) {\n    var lowerCaseArr = i18n[arrName].map(function (v) {\n      return v.toLowerCase();\n    });\n    var index = lowerCaseArr.indexOf(v.toLowerCase());\n\n    if (index > -1) {\n      return index;\n    }\n\n    return null;\n  };\n};\n\nfunction assign(origObj) {\n  var args = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    args[_i - 1] = arguments[_i];\n  }\n\n  for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n    var obj = args_1[_a];\n\n    for (var key in obj) {\n      // @ts-ignore ex\n      origObj[key] = obj[key];\n    }\n  }\n\n  return origObj;\n}\n\nvar dayNames = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\nvar monthNames = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\nvar monthNamesShort = shorten(monthNames, 3);\nvar dayNamesShort = shorten(dayNames, 3);\nvar defaultI18n = {\n  dayNamesShort: dayNamesShort,\n  dayNames: dayNames,\n  monthNamesShort: monthNamesShort,\n  monthNames: monthNames,\n  amPm: [\"am\", \"pm\"],\n  DoFn: function (dayOfMonth) {\n    return dayOfMonth + [\"th\", \"st\", \"nd\", \"rd\"][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];\n  }\n};\nvar globalI18n = assign({}, defaultI18n);\n\nvar setGlobalDateI18n = function (i18n) {\n  return globalI18n = assign(globalI18n, i18n);\n};\n\nvar regexEscape = function (str) {\n  return str.replace(/[|\\\\{()[^$+*?.-]/g, \"\\\\$&\");\n};\n\nvar pad = function (val, len) {\n  if (len === void 0) {\n    len = 2;\n  }\n\n  val = String(val);\n\n  while (val.length < len) {\n    val = \"0\" + val;\n  }\n\n  return val;\n};\n\nvar formatFlags = {\n  D: function (dateObj) {\n    return String(dateObj.getDate());\n  },\n  DD: function (dateObj) {\n    return pad(dateObj.getDate());\n  },\n  Do: function (dateObj, i18n) {\n    return i18n.DoFn(dateObj.getDate());\n  },\n  d: function (dateObj) {\n    return String(dateObj.getDay());\n  },\n  dd: function (dateObj) {\n    return pad(dateObj.getDay());\n  },\n  ddd: function (dateObj, i18n) {\n    return i18n.dayNamesShort[dateObj.getDay()];\n  },\n  dddd: function (dateObj, i18n) {\n    return i18n.dayNames[dateObj.getDay()];\n  },\n  M: function (dateObj) {\n    return String(dateObj.getMonth() + 1);\n  },\n  MM: function (dateObj) {\n    return pad(dateObj.getMonth() + 1);\n  },\n  MMM: function (dateObj, i18n) {\n    return i18n.monthNamesShort[dateObj.getMonth()];\n  },\n  MMMM: function (dateObj, i18n) {\n    return i18n.monthNames[dateObj.getMonth()];\n  },\n  YY: function (dateObj) {\n    return pad(String(dateObj.getFullYear()), 4).substr(2);\n  },\n  YYYY: function (dateObj) {\n    return pad(dateObj.getFullYear(), 4);\n  },\n  h: function (dateObj) {\n    return String(dateObj.getHours() % 12 || 12);\n  },\n  hh: function (dateObj) {\n    return pad(dateObj.getHours() % 12 || 12);\n  },\n  H: function (dateObj) {\n    return String(dateObj.getHours());\n  },\n  HH: function (dateObj) {\n    return pad(dateObj.getHours());\n  },\n  m: function (dateObj) {\n    return String(dateObj.getMinutes());\n  },\n  mm: function (dateObj) {\n    return pad(dateObj.getMinutes());\n  },\n  s: function (dateObj) {\n    return String(dateObj.getSeconds());\n  },\n  ss: function (dateObj) {\n    return pad(dateObj.getSeconds());\n  },\n  S: function (dateObj) {\n    return String(Math.round(dateObj.getMilliseconds() / 100));\n  },\n  SS: function (dateObj) {\n    return pad(Math.round(dateObj.getMilliseconds() / 10), 2);\n  },\n  SSS: function (dateObj) {\n    return pad(dateObj.getMilliseconds(), 3);\n  },\n  a: function (dateObj, i18n) {\n    return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];\n  },\n  A: function (dateObj, i18n) {\n    return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();\n  },\n  ZZ: function (dateObj) {\n    var offset = dateObj.getTimezoneOffset();\n    return (offset > 0 ? \"-\" : \"+\") + pad(Math.floor(Math.abs(offset) / 60) * 100 + Math.abs(offset) % 60, 4);\n  },\n  Z: function (dateObj) {\n    var offset = dateObj.getTimezoneOffset();\n    return (offset > 0 ? \"-\" : \"+\") + pad(Math.floor(Math.abs(offset) / 60), 2) + \":\" + pad(Math.abs(offset) % 60, 2);\n  }\n};\n\nvar monthParse = function (v) {\n  return +v - 1;\n};\n\nvar emptyDigits = [null, twoDigitsOptional];\nvar emptyWord = [null, word];\nvar amPm = [\"isPm\", word, function (v, i18n) {\n  var val = v.toLowerCase();\n\n  if (val === i18n.amPm[0]) {\n    return 0;\n  } else if (val === i18n.amPm[1]) {\n    return 1;\n  }\n\n  return null;\n}];\nvar timezoneOffset = [\"timezoneOffset\", \"[^\\\\s]*?[\\\\+\\\\-]\\\\d\\\\d:?\\\\d\\\\d|[^\\\\s]*?Z?\", function (v) {\n  var parts = (v + \"\").match(/([+-]|\\d\\d)/gi);\n\n  if (parts) {\n    var minutes = +parts[1] * 60 + parseInt(parts[2], 10);\n    return parts[0] === \"+\" ? minutes : -minutes;\n  }\n\n  return 0;\n}];\nvar parseFlags = {\n  D: [\"day\", twoDigitsOptional],\n  DD: [\"day\", twoDigits],\n  Do: [\"day\", twoDigitsOptional + word, function (v) {\n    return parseInt(v, 10);\n  }],\n  M: [\"month\", twoDigitsOptional, monthParse],\n  MM: [\"month\", twoDigits, monthParse],\n  YY: [\"year\", twoDigits, function (v) {\n    var now = new Date();\n    var cent = +(\"\" + now.getFullYear()).substr(0, 2);\n    return +(\"\" + (+v > 68 ? cent - 1 : cent) + v);\n  }],\n  h: [\"hour\", twoDigitsOptional, undefined, \"isPm\"],\n  hh: [\"hour\", twoDigits, undefined, \"isPm\"],\n  H: [\"hour\", twoDigitsOptional],\n  HH: [\"hour\", twoDigits],\n  m: [\"minute\", twoDigitsOptional],\n  mm: [\"minute\", twoDigits],\n  s: [\"second\", twoDigitsOptional],\n  ss: [\"second\", twoDigits],\n  YYYY: [\"year\", fourDigits],\n  S: [\"millisecond\", \"\\\\d\", function (v) {\n    return +v * 100;\n  }],\n  SS: [\"millisecond\", twoDigits, function (v) {\n    return +v * 10;\n  }],\n  SSS: [\"millisecond\", threeDigits],\n  d: emptyDigits,\n  dd: emptyDigits,\n  ddd: emptyWord,\n  dddd: emptyWord,\n  MMM: [\"month\", word, monthUpdate(\"monthNamesShort\")],\n  MMMM: [\"month\", word, monthUpdate(\"monthNames\")],\n  a: amPm,\n  A: amPm,\n  ZZ: timezoneOffset,\n  Z: timezoneOffset\n}; // Some common format strings\n\nvar globalMasks = {\n  default: \"ddd MMM DD YYYY HH:mm:ss\",\n  shortDate: \"M/D/YY\",\n  mediumDate: \"MMM D, YYYY\",\n  longDate: \"MMMM D, YYYY\",\n  fullDate: \"dddd, MMMM D, YYYY\",\n  isoDate: \"YYYY-MM-DD\",\n  isoDateTime: \"YYYY-MM-DDTHH:mm:ssZ\",\n  shortTime: \"HH:mm\",\n  mediumTime: \"HH:mm:ss\",\n  longTime: \"HH:mm:ss.SSS\"\n};\n\nvar setGlobalDateMasks = function (masks) {\n  return assign(globalMasks, masks);\n};\n/***\n * Format a date\n * @method format\n * @param {Date|number} dateObj\n * @param {string} mask Format of the date, i.e. 'mm-dd-yy' or 'shortDate'\n * @returns {string} Formatted date string\n */\n\n\nvar format = function (dateObj, mask, i18n) {\n  if (mask === void 0) {\n    mask = globalMasks[\"default\"];\n  }\n\n  if (i18n === void 0) {\n    i18n = {};\n  }\n\n  if (typeof dateObj === \"number\") {\n    dateObj = new Date(dateObj);\n  }\n\n  if (Object.prototype.toString.call(dateObj) !== \"[object Date]\" || isNaN(dateObj.getTime())) {\n    throw new Error(\"Invalid Date pass to format\");\n  }\n\n  mask = globalMasks[mask] || mask;\n  var literals = []; // Make literals inactive by replacing them with @@@\n\n  mask = mask.replace(literal, function ($0, $1) {\n    literals.push($1);\n    return \"@@@\";\n  });\n  var combinedI18nSettings = assign(assign({}, globalI18n), i18n); // Apply formatting rules\n\n  mask = mask.replace(token, function ($0) {\n    return formatFlags[$0](dateObj, combinedI18nSettings);\n  }); // Inline literal values back into the formatted value\n\n  return mask.replace(/@@@/g, function () {\n    return literals.shift();\n  });\n};\n/**\n * Parse a date string into a Javascript Date object /\n * @method parse\n * @param {string} dateStr Date string\n * @param {string} format Date parse format\n * @param {i18n} I18nSettingsOptional Full or subset of I18N settings\n * @returns {Date|null} Returns Date object. Returns null what date string is invalid or doesn't match format\n */\n\n\nfunction parse(dateStr, format, i18n) {\n  if (i18n === void 0) {\n    i18n = {};\n  }\n\n  if (typeof format !== \"string\") {\n    throw new Error(\"Invalid format in fecha parse\");\n  } // Check to see if the format is actually a mask\n\n\n  format = globalMasks[format] || format; // Avoid regular expression denial of service, fail early for really long strings\n  // https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS\n\n  if (dateStr.length > 1000) {\n    return null;\n  } // Default to the beginning of the year.\n\n\n  var today = new Date();\n  var dateInfo = {\n    year: today.getFullYear(),\n    month: 0,\n    day: 1,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    millisecond: 0,\n    isPm: null,\n    timezoneOffset: null\n  };\n  var parseInfo = [];\n  var literals = []; // Replace all the literals with @@@. Hopefully a string that won't exist in the format\n\n  var newFormat = format.replace(literal, function ($0, $1) {\n    literals.push(regexEscape($1));\n    return \"@@@\";\n  });\n  var specifiedFields = {};\n  var requiredFields = {}; // Change every token that we find into the correct regex\n\n  newFormat = regexEscape(newFormat).replace(token, function ($0) {\n    var info = parseFlags[$0];\n    var field = info[0],\n        regex = info[1],\n        requiredField = info[3]; // Check if the person has specified the same field twice. This will lead to confusing results.\n\n    if (specifiedFields[field]) {\n      throw new Error(\"Invalid format. \" + field + \" specified twice in format\");\n    }\n\n    specifiedFields[field] = true; // Check if there are any required fields. For instance, 12 hour time requires AM/PM specified\n\n    if (requiredField) {\n      requiredFields[requiredField] = true;\n    }\n\n    parseInfo.push(info);\n    return \"(\" + regex + \")\";\n  }); // Check all the required fields are present\n\n  Object.keys(requiredFields).forEach(function (field) {\n    if (!specifiedFields[field]) {\n      throw new Error(\"Invalid format. \" + field + \" is required in specified format\");\n    }\n  }); // Add back all the literals after\n\n  newFormat = newFormat.replace(/@@@/g, function () {\n    return literals.shift();\n  }); // Check if the date string matches the format. If it doesn't return null\n\n  var matches = dateStr.match(new RegExp(newFormat, \"i\"));\n\n  if (!matches) {\n    return null;\n  }\n\n  var combinedI18nSettings = assign(assign({}, globalI18n), i18n); // For each match, call the parser function for that date part\n\n  for (var i = 1; i < matches.length; i++) {\n    var _a = parseInfo[i - 1],\n        field = _a[0],\n        parser = _a[2];\n    var value = parser ? parser(matches[i], combinedI18nSettings) : +matches[i]; // If the parser can't make sense of the value, return null\n\n    if (value == null) {\n      return null;\n    }\n\n    dateInfo[field] = value;\n  }\n\n  if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {\n    dateInfo.hour = +dateInfo.hour + 12;\n  } else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {\n    dateInfo.hour = 0;\n  }\n\n  var dateWithoutTZ = new Date(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute, dateInfo.second, dateInfo.millisecond);\n  var validateFields = [[\"month\", \"getMonth\"], [\"day\", \"getDate\"], [\"hour\", \"getHours\"], [\"minute\", \"getMinutes\"], [\"second\", \"getSeconds\"]];\n\n  for (var i = 0, len = validateFields.length; i < len; i++) {\n    // Check to make sure the date field is within the allowed range. Javascript dates allows values\n    // outside the allowed range. If the values don't match the value was invalid\n    if (specifiedFields[validateFields[i][0]] && dateInfo[validateFields[i][0]] !== dateWithoutTZ[validateFields[i][1]]()) {\n      return null;\n    }\n  }\n\n  if (dateInfo.timezoneOffset == null) {\n    return dateWithoutTZ;\n  }\n\n  return new Date(Date.UTC(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute - dateInfo.timezoneOffset, dateInfo.second, dateInfo.millisecond));\n}\n\nvar fecha = {\n  format: format,\n  parse: parse,\n  defaultI18n: defaultI18n,\n  setGlobalDateI18n: setGlobalDateI18n,\n  setGlobalDateMasks: setGlobalDateMasks\n};\nexport default fecha;\nexport { assign, format, parse, defaultI18n, setGlobalDateI18n, setGlobalDateMasks };","map":{"version":3,"mappings":"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","names":["token","twoDigitsOptional","twoDigits","threeDigits","fourDigits","word","literal","shorten","arr","sLen","newArr","i","len","length","push","substr","monthUpdate","arrName","v","i18n","lowerCaseArr","map","toLowerCase","index","indexOf","assign","origObj","args","_a","obj","key","dayNames","monthNames","monthNamesShort","dayNamesShort","defaultI18n","amPm","DoFn","dayOfMonth","globalI18n","setGlobalDateI18n","regexEscape","str","replace","pad","val","String","formatFlags","D","dateObj","getDate","DD","Do","d","getDay","dd","ddd","dddd","M","getMonth","MM","MMM","MMMM","YY","getFullYear","YYYY","h","getHours","hh","H","HH","m","getMinutes","mm","s","getSeconds","ss","S","Math","round","getMilliseconds","SS","SSS","a","A","toUpperCase","ZZ","offset","getTimezoneOffset","floor","abs","Z","monthParse","emptyDigits","emptyWord","timezoneOffset","parts","match","minutes","parseInt","parseFlags","now","Date","cent","undefined","globalMasks","default","shortDate","mediumDate","longDate","fullDate","isoDate","isoDateTime","shortTime","mediumTime","longTime","setGlobalDateMasks","masks","format","mask","Object","prototype","toString","call","isNaN","getTime","Error","literals","$0","$1","combinedI18nSettings","shift","parse","dateStr","today","dateInfo","year","month","day","hour","minute","second","millisecond","isPm","parseInfo","newFormat","specifiedFields","requiredFields","info","regex","requiredField","field","keys","forEach","matches","RegExp","parser","value","dateWithoutTZ","validateFields","UTC"],"sources":["/Users/imac/Documents/GitHub/GishaLoans/frontend/node_modules/fecha/src/fecha.ts"],"sourcesContent":["const token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\\1?|[aA]|\"[^\"]*\"|'[^']*'/g;\nconst twoDigitsOptional = \"[1-9]\\\\d?\";\nconst twoDigits = \"\\\\d\\\\d\";\nconst threeDigits = \"\\\\d{3}\";\nconst fourDigits = \"\\\\d{4}\";\nconst word = \"[^\\\\s]+\";\nconst literal = /\\[([^]*?)\\]/gm;\n\ntype DateInfo = {\n  year: number;\n  month: number;\n  day: number;\n  hour: number;\n  minute: number;\n  second: number;\n  millisecond: number;\n  isPm: number | null;\n  timezoneOffset: number | null;\n};\n\nexport type I18nSettings = {\n  amPm: [string, string];\n  dayNames: Days;\n  dayNamesShort: Days;\n  monthNames: Months;\n  monthNamesShort: Months;\n  DoFn(dayOfMonth: number): string;\n};\n\nexport type I18nSettingsOptional = Partial<I18nSettings>;\n\nexport type Days = [string, string, string, string, string, string, string];\nexport type Months = [\n  string,\n  string,\n  string,\n  string,\n  string,\n  string,\n  string,\n  string,\n  string,\n  string,\n  string,\n  string\n];\n\nfunction shorten<T extends string[]>(arr: T, sLen: number): string[] {\n  const newArr: string[] = [];\n  for (let i = 0, len = arr.length; i < len; i++) {\n    newArr.push(arr[i].substr(0, sLen));\n  }\n  return newArr;\n}\n\nconst monthUpdate = (\n  arrName: \"monthNames\" | \"monthNamesShort\" | \"dayNames\" | \"dayNamesShort\"\n) => (v: string, i18n: I18nSettings): number | null => {\n  const lowerCaseArr = i18n[arrName].map(v => v.toLowerCase());\n  const index = lowerCaseArr.indexOf(v.toLowerCase());\n  if (index > -1) {\n    return index;\n  }\n  return null;\n};\n\nexport function assign<A>(a: A): A;\nexport function assign<A, B>(a: A, b: B): A & B;\nexport function assign<A, B, C>(a: A, b: B, c: C): A & B & C;\nexport function assign<A, B, C, D>(a: A, b: B, c: C, d: D): A & B & C & D;\nexport function assign(origObj: any, ...args: any[]): any {\n  for (const obj of args) {\n    for (const key in obj) {\n      // @ts-ignore ex\n      origObj[key] = obj[key];\n    }\n  }\n  return origObj;\n}\n\nconst dayNames: Days = [\n  \"Sunday\",\n  \"Monday\",\n  \"Tuesday\",\n  \"Wednesday\",\n  \"Thursday\",\n  \"Friday\",\n  \"Saturday\"\n];\nconst monthNames: Months = [\n  \"January\",\n  \"February\",\n  \"March\",\n  \"April\",\n  \"May\",\n  \"June\",\n  \"July\",\n  \"August\",\n  \"September\",\n  \"October\",\n  \"November\",\n  \"December\"\n];\n\nconst monthNamesShort: Months = shorten(monthNames, 3) as Months;\nconst dayNamesShort: Days = shorten(dayNames, 3) as Days;\n\nconst defaultI18n: I18nSettings = {\n  dayNamesShort,\n  dayNames,\n  monthNamesShort,\n  monthNames,\n  amPm: [\"am\", \"pm\"],\n  DoFn(dayOfMonth: number) {\n    return (\n      dayOfMonth +\n      [\"th\", \"st\", \"nd\", \"rd\"][\n        dayOfMonth % 10 > 3\n          ? 0\n          : ((dayOfMonth - (dayOfMonth % 10) !== 10 ? 1 : 0) * dayOfMonth) % 10\n      ]\n    );\n  }\n};\nlet globalI18n = assign({}, defaultI18n);\nconst setGlobalDateI18n = (i18n: I18nSettingsOptional): I18nSettings =>\n  (globalI18n = assign(globalI18n, i18n));\n\nconst regexEscape = (str: string): string =>\n  str.replace(/[|\\\\{()[^$+*?.-]/g, \"\\\\$&\");\n\nconst pad = (val: string | number, len = 2): string => {\n  val = String(val);\n  while (val.length < len) {\n    val = \"0\" + val;\n  }\n  return val;\n};\n\nconst formatFlags: Record<\n  string,\n  (dateObj: Date, i18n: I18nSettings) => string\n> = {\n  D: (dateObj: Date): string => String(dateObj.getDate()),\n  DD: (dateObj: Date): string => pad(dateObj.getDate()),\n  Do: (dateObj: Date, i18n: I18nSettings): string =>\n    i18n.DoFn(dateObj.getDate()),\n  d: (dateObj: Date): string => String(dateObj.getDay()),\n  dd: (dateObj: Date): string => pad(dateObj.getDay()),\n  ddd: (dateObj: Date, i18n: I18nSettings): string =>\n    i18n.dayNamesShort[dateObj.getDay()],\n  dddd: (dateObj: Date, i18n: I18nSettings): string =>\n    i18n.dayNames[dateObj.getDay()],\n  M: (dateObj: Date): string => String(dateObj.getMonth() + 1),\n  MM: (dateObj: Date): string => pad(dateObj.getMonth() + 1),\n  MMM: (dateObj: Date, i18n: I18nSettings): string =>\n    i18n.monthNamesShort[dateObj.getMonth()],\n  MMMM: (dateObj: Date, i18n: I18nSettings): string =>\n    i18n.monthNames[dateObj.getMonth()],\n  YY: (dateObj: Date): string =>\n    pad(String(dateObj.getFullYear()), 4).substr(2),\n  YYYY: (dateObj: Date): string => pad(dateObj.getFullYear(), 4),\n  h: (dateObj: Date): string => String(dateObj.getHours() % 12 || 12),\n  hh: (dateObj: Date): string => pad(dateObj.getHours() % 12 || 12),\n  H: (dateObj: Date): string => String(dateObj.getHours()),\n  HH: (dateObj: Date): string => pad(dateObj.getHours()),\n  m: (dateObj: Date): string => String(dateObj.getMinutes()),\n  mm: (dateObj: Date): string => pad(dateObj.getMinutes()),\n  s: (dateObj: Date): string => String(dateObj.getSeconds()),\n  ss: (dateObj: Date): string => pad(dateObj.getSeconds()),\n  S: (dateObj: Date): string =>\n    String(Math.round(dateObj.getMilliseconds() / 100)),\n  SS: (dateObj: Date): string =>\n    pad(Math.round(dateObj.getMilliseconds() / 10), 2),\n  SSS: (dateObj: Date): string => pad(dateObj.getMilliseconds(), 3),\n  a: (dateObj: Date, i18n: I18nSettings): string =>\n    dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1],\n  A: (dateObj: Date, i18n: I18nSettings): string =>\n    dateObj.getHours() < 12\n      ? i18n.amPm[0].toUpperCase()\n      : i18n.amPm[1].toUpperCase(),\n  ZZ(dateObj: Date): string {\n    const offset = dateObj.getTimezoneOffset();\n    return (\n      (offset > 0 ? \"-\" : \"+\") +\n      pad(Math.floor(Math.abs(offset) / 60) * 100 + (Math.abs(offset) % 60), 4)\n    );\n  },\n  Z(dateObj: Date): string {\n    const offset = dateObj.getTimezoneOffset();\n    return (\n      (offset > 0 ? \"-\" : \"+\") +\n      pad(Math.floor(Math.abs(offset) / 60), 2) +\n      \":\" +\n      pad(Math.abs(offset) % 60, 2)\n    );\n  }\n};\n\ntype ParseInfo = [\n  keyof DateInfo,\n  string,\n  ((v: string, i18n: I18nSettings) => number | null)?,\n  string?\n];\nconst monthParse = (v: string): number => +v - 1;\nconst emptyDigits: ParseInfo = [null, twoDigitsOptional];\nconst emptyWord: ParseInfo = [null, word];\nconst amPm: ParseInfo = [\n  \"isPm\",\n  word,\n  (v: string, i18n: I18nSettings): number | null => {\n    const val = v.toLowerCase();\n    if (val === i18n.amPm[0]) {\n      return 0;\n    } else if (val === i18n.amPm[1]) {\n      return 1;\n    }\n    return null;\n  }\n];\nconst timezoneOffset: ParseInfo = [\n  \"timezoneOffset\",\n  \"[^\\\\s]*?[\\\\+\\\\-]\\\\d\\\\d:?\\\\d\\\\d|[^\\\\s]*?Z?\",\n  (v: string): number | null => {\n    const parts = (v + \"\").match(/([+-]|\\d\\d)/gi);\n\n    if (parts) {\n      const minutes = +parts[1] * 60 + parseInt(parts[2], 10);\n      return parts[0] === \"+\" ? minutes : -minutes;\n    }\n\n    return 0;\n  }\n];\nconst parseFlags: Record<string, ParseInfo> = {\n  D: [\"day\", twoDigitsOptional],\n  DD: [\"day\", twoDigits],\n  Do: [\"day\", twoDigitsOptional + word, (v: string): number => parseInt(v, 10)],\n  M: [\"month\", twoDigitsOptional, monthParse],\n  MM: [\"month\", twoDigits, monthParse],\n  YY: [\n    \"year\",\n    twoDigits,\n    (v: string): number => {\n      const now = new Date();\n      const cent = +(\"\" + now.getFullYear()).substr(0, 2);\n      return +(\"\" + (+v > 68 ? cent - 1 : cent) + v);\n    }\n  ],\n  h: [\"hour\", twoDigitsOptional, undefined, \"isPm\"],\n  hh: [\"hour\", twoDigits, undefined, \"isPm\"],\n  H: [\"hour\", twoDigitsOptional],\n  HH: [\"hour\", twoDigits],\n  m: [\"minute\", twoDigitsOptional],\n  mm: [\"minute\", twoDigits],\n  s: [\"second\", twoDigitsOptional],\n  ss: [\"second\", twoDigits],\n  YYYY: [\"year\", fourDigits],\n  S: [\"millisecond\", \"\\\\d\", (v: string): number => +v * 100],\n  SS: [\"millisecond\", twoDigits, (v: string): number => +v * 10],\n  SSS: [\"millisecond\", threeDigits],\n  d: emptyDigits,\n  dd: emptyDigits,\n  ddd: emptyWord,\n  dddd: emptyWord,\n  MMM: [\"month\", word, monthUpdate(\"monthNamesShort\")],\n  MMMM: [\"month\", word, monthUpdate(\"monthNames\")],\n  a: amPm,\n  A: amPm,\n  ZZ: timezoneOffset,\n  Z: timezoneOffset\n};\n\n// Some common format strings\nconst globalMasks: { [key: string]: string } = {\n  default: \"ddd MMM DD YYYY HH:mm:ss\",\n  shortDate: \"M/D/YY\",\n  mediumDate: \"MMM D, YYYY\",\n  longDate: \"MMMM D, YYYY\",\n  fullDate: \"dddd, MMMM D, YYYY\",\n  isoDate: \"YYYY-MM-DD\",\n  isoDateTime: \"YYYY-MM-DDTHH:mm:ssZ\",\n  shortTime: \"HH:mm\",\n  mediumTime: \"HH:mm:ss\",\n  longTime: \"HH:mm:ss.SSS\"\n};\nconst setGlobalDateMasks = (masks: {\n  [key: string]: string;\n}): { [key: string]: string } => assign(globalMasks, masks);\n\n/***\n * Format a date\n * @method format\n * @param {Date|number} dateObj\n * @param {string} mask Format of the date, i.e. 'mm-dd-yy' or 'shortDate'\n * @returns {string} Formatted date string\n */\nconst format = (\n  dateObj: Date,\n  mask: string = globalMasks[\"default\"],\n  i18n: I18nSettingsOptional = {}\n): string => {\n  if (typeof dateObj === \"number\") {\n    dateObj = new Date(dateObj);\n  }\n\n  if (\n    Object.prototype.toString.call(dateObj) !== \"[object Date]\" ||\n    isNaN(dateObj.getTime())\n  ) {\n    throw new Error(\"Invalid Date pass to format\");\n  }\n\n  mask = globalMasks[mask] || mask;\n\n  const literals: string[] = [];\n\n  // Make literals inactive by replacing them with @@@\n  mask = mask.replace(literal, function($0, $1) {\n    literals.push($1);\n    return \"@@@\";\n  });\n\n  const combinedI18nSettings: I18nSettings = assign(\n    assign({}, globalI18n),\n    i18n\n  );\n  // Apply formatting rules\n  mask = mask.replace(token, $0 =>\n    formatFlags[$0](dateObj, combinedI18nSettings)\n  );\n  // Inline literal values back into the formatted value\n  return mask.replace(/@@@/g, () => literals.shift());\n};\n\n/**\n * Parse a date string into a Javascript Date object /\n * @method parse\n * @param {string} dateStr Date string\n * @param {string} format Date parse format\n * @param {i18n} I18nSettingsOptional Full or subset of I18N settings\n * @returns {Date|null} Returns Date object. Returns null what date string is invalid or doesn't match format\n */\nfunction parse(\n  dateStr: string,\n  format: string,\n  i18n: I18nSettingsOptional = {}\n): Date | null {\n  if (typeof format !== \"string\") {\n    throw new Error(\"Invalid format in fecha parse\");\n  }\n\n  // Check to see if the format is actually a mask\n  format = globalMasks[format] || format;\n\n  // Avoid regular expression denial of service, fail early for really long strings\n  // https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS\n  if (dateStr.length > 1000) {\n    return null;\n  }\n\n  // Default to the beginning of the year.\n  const today = new Date();\n  const dateInfo: DateInfo = {\n    year: today.getFullYear(),\n    month: 0,\n    day: 1,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    millisecond: 0,\n    isPm: null,\n    timezoneOffset: null\n  };\n  const parseInfo: ParseInfo[] = [];\n  const literals: string[] = [];\n\n  // Replace all the literals with @@@. Hopefully a string that won't exist in the format\n  let newFormat = format.replace(literal, ($0, $1) => {\n    literals.push(regexEscape($1));\n    return \"@@@\";\n  });\n  const specifiedFields: { [field: string]: boolean } = {};\n  const requiredFields: { [field: string]: boolean } = {};\n\n  // Change every token that we find into the correct regex\n  newFormat = regexEscape(newFormat).replace(token, $0 => {\n    const info = parseFlags[$0];\n    const [field, regex, , requiredField] = info;\n\n    // Check if the person has specified the same field twice. This will lead to confusing results.\n    if (specifiedFields[field]) {\n      throw new Error(`Invalid format. ${field} specified twice in format`);\n    }\n\n    specifiedFields[field] = true;\n\n    // Check if there are any required fields. For instance, 12 hour time requires AM/PM specified\n    if (requiredField) {\n      requiredFields[requiredField] = true;\n    }\n\n    parseInfo.push(info);\n    return \"(\" + regex + \")\";\n  });\n\n  // Check all the required fields are present\n  Object.keys(requiredFields).forEach(field => {\n    if (!specifiedFields[field]) {\n      throw new Error(\n        `Invalid format. ${field} is required in specified format`\n      );\n    }\n  });\n\n  // Add back all the literals after\n  newFormat = newFormat.replace(/@@@/g, () => literals.shift());\n\n  // Check if the date string matches the format. If it doesn't return null\n  const matches = dateStr.match(new RegExp(newFormat, \"i\"));\n  if (!matches) {\n    return null;\n  }\n\n  const combinedI18nSettings: I18nSettings = assign(\n    assign({}, globalI18n),\n    i18n\n  );\n\n  // For each match, call the parser function for that date part\n  for (let i = 1; i < matches.length; i++) {\n    const [field, , parser] = parseInfo[i - 1];\n    const value = parser\n      ? parser(matches[i], combinedI18nSettings)\n      : +matches[i];\n\n    // If the parser can't make sense of the value, return null\n    if (value == null) {\n      return null;\n    }\n\n    dateInfo[field] = value;\n  }\n\n  if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {\n    dateInfo.hour = +dateInfo.hour + 12;\n  } else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {\n    dateInfo.hour = 0;\n  }\n\n  const dateWithoutTZ: Date = new Date(\n    dateInfo.year,\n    dateInfo.month,\n    dateInfo.day,\n    dateInfo.hour,\n    dateInfo.minute,\n    dateInfo.second,\n    dateInfo.millisecond\n  );\n\n  const validateFields: [\n    \"month\" | \"day\" | \"hour\" | \"minute\" | \"second\",\n    \"getMonth\" | \"getDate\" | \"getHours\" | \"getMinutes\" | \"getSeconds\"\n  ][] = [\n    [\"month\", \"getMonth\"],\n    [\"day\", \"getDate\"],\n    [\"hour\", \"getHours\"],\n    [\"minute\", \"getMinutes\"],\n    [\"second\", \"getSeconds\"]\n  ];\n  for (let i = 0, len = validateFields.length; i < len; i++) {\n    // Check to make sure the date field is within the allowed range. Javascript dates allows values\n    // outside the allowed range. If the values don't match the value was invalid\n    if (\n      specifiedFields[validateFields[i][0]] &&\n      dateInfo[validateFields[i][0]] !== dateWithoutTZ[validateFields[i][1]]()\n    ) {\n      return null;\n    }\n  }\n\n  if (dateInfo.timezoneOffset == null) {\n    return dateWithoutTZ;\n  }\n\n  return new Date(\n    Date.UTC(\n      dateInfo.year,\n      dateInfo.month,\n      dateInfo.day,\n      dateInfo.hour,\n      dateInfo.minute - dateInfo.timezoneOffset,\n      dateInfo.second,\n      dateInfo.millisecond\n    )\n  );\n}\nexport default {\n  format,\n  parse,\n  defaultI18n,\n  setGlobalDateI18n,\n  setGlobalDateMasks\n};\nexport { format, parse, defaultI18n, setGlobalDateI18n, setGlobalDateMasks };\n"]},"metadata":{},"sourceType":"module"}